# 公式提供のPDFを読んでメモ
- これ https://phaser.io/account/downloads

## runner

シンプルなランナーゲーム。

`Player` は `GameObject.Rectangle` を継承している。自身のコードでは `Sprite` を継承しているが、問題なさそう。

障害物は、インスタンス作成時に `scene` のみを受け取る `Generator` クラスによってシーンに追加している。
`Generator` はランダムな `delayedCall` ごとに再帰で生成コードを呼ぶ。インスタンス生成時にコンストラクター内で `this.init()` を呼び、一定時間ごとに障害物を生成し続ける。

`tweens.add` は `onComplete` でTween終了時のコールバックを渡せる。画面外に移動させた後 `destroy` するとかできる。
非表示になったオブジェクトは再利用しないなら `destory` したほうが多分よさそう。

ゲームオーバー時はシーン遷移するが、スコアの引き回しは `registry` で行っている。問題なし。

シーンに関連するちょっとした処理はクラスのメソッドとして定義して `create()` 内で呼んでいる。これもよさそう。

## starshake

普通によくできたシューティングゲーム。
表示されるスプライト、背景、パーティクルが常ににぎやかに動いているのがゲームらしさに繋がっていそう。
自作ゲームでも賑やかしになるようなオブジェクトがほしいところ。

ゲーム開始時点で `preload` しておきたい処理をすべて `BootLoader` シーンに切り出しており、起動直後（タイトルより前）に呼んでいる。
ロードが重くなってきたらこうするといいかもしれない。`preload` ではアセットの読み込み以外に、レジストリの初期化もここでやっている。

`GameObject` は組み込みで `getData('key')` と `setData('key')` を持っており、メンバー変数に落とさなくてもオブジェクトごとの情報を格納、参照できる。
ただし、`Data` には `any` な値を入れられるが、`getData` 時に型推論が効かないのでそこがちょっと微妙かもしれない。

シーン間遷移にちょっとしたシャッターエフェクトが用いられているが、「`next` を受け取り、自身を再生したあとに `next` に再遷移する」`Transition` というシーンを用意しており参考になる。エフェクト自体は愚直に `Rectangle` を描画してTweenしている。

Tweenで変化させる値は `{ from: 0, to: 1 }` のように書けることが判明。撃墜時のスコア表示方法は自前のコードとほぼ同一。

敵機は `FoeGenerator` クラスで、`foe` というゲームオブジェクト生成している。生成系は `Generator` 方式でやるのがよいかもしれない。
非常に参考になるのが、STGあるあるの「規則的に並んだ敵機」の生成を、ループ時に `delay: i * 100` のように一定間隔Tweenを遅らせて実行する方法で実現していること。
Phaserでは、Tweenでオブジェクトを移動した際も見かけだけでなく当たり判定が追従するのがポイント。

敵機が発射した弾（当たるとミス）も単純な `FoeShot` というゲームオブジェクト。

# Ourcade提供のPDFを読んでメモ
- これ https://ourcade.co/books/infinite-runner-phaser3/
